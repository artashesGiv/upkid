
function _instanceof (e, t) { return t != null && typeof Symbol !== 'undefined' && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : e instanceof t } function _classCallCheck (e, t) { if (!_instanceof(e, t)) throw new TypeError('Cannot call a class as a function') } function _defineProperties (e, t) { for (let l = 0; l < t.length; l++) { const n = t[l]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function _createClass (e, t, l) { return t && _defineProperties(e.prototype, t), l && _defineProperties(e, l), e } const SCROLLABLE_CLASSNAME = 'sl--scrollable'; const FILLGAP_CLASSNAME = 'sl--fillgap'; const PREVENT_SCROLL_DATASET = 'slPrevented'; const DELTA_DATASET = 'slDelta'; const FILLGAP_AVAILABLE_METHODS = ['padding', 'margin', 'width']; let _state = !0; let _queue = 0; let _scrollableTargets = []; let _temporaryScrollableTargets = []; let _fillGapMethod = FILLGAP_AVAILABLE_METHODS[0]; let _fillGapSelectors = ['body', '.'.concat(FILLGAP_CLASSNAME)]; let _fillGapTargets = []; const generateSelector = function (e) { return e.join(', ') }; const eachNode = function (e, t) { for (let l = 0; l < e.length; l++)t(e[l]) }; const findTarget = function (e) { for (var t = e.target; !(t === null || t.classList && t.classList.contains(SCROLLABLE_CLASSNAME));)t = t.parentNode; return t }; const throwError = function (e) { console.error('[scroll-lock] '.concat(e)) }; const touchstartEventHandler = function (e, t) { const l = findTarget(e); if (l) { l.scrollTop; const n = l.scrollHeight; const r = l.clientHeight; l.dataset[DELTA_DATASET] = e.touches[0].clientY, r === n && (l.dataset[PREVENT_SCROLL_DATASET] = 'true') } }; const touchmoveEventHandler = function (e, t) { if (!t.getState()) { const l = findTarget(e); if (l) if (l.dataset[PREVENT_SCROLL_DATASET] === 'true')e.preventDefault(); else { const n = l.scrollTop; const r = l.scrollHeight; const a = n + l.offsetHeight; const o = parseFloat(l.dataset[DELTA_DATASET]); const i = e.touches[0].clientY; n <= 0 ? o < i && e.preventDefault() : r <= a && i < o && e.preventDefault() } else e.preventDefault() } }; const touchendEventHandler = function (e, t) { const l = findTarget(e); l && (l.dataset[PREVENT_SCROLL_DATASET] = 'false') }; const bindEvents = function (t) { document.addEventListener('touchstart', e => touchstartEventHandler(e, t)), document.addEventListener('touchmove', e => touchmoveEventHandler(e, t), { passive: !1 }), document.addEventListener('touchend', e => touchendEventHandler(e, t)) }; const ScrollLock = (function () { function e () { _classCallCheck(this, e), bindEvents(this) } return _createClass(e, [{ key: 'getState', value () { return _state } }, { key: 'hide', value (e) { return _queue <= 0 && (this._fillGaps(), document.body.style.overflow = 'hidden', _state = !1), this._setTemporaryScrollableTargets(e), _queue++, this } }, { key: 'show', value () { return --_queue <= 0 ? (document.body.style.overflow = '', this._unfillGaps(), _state = !0) : this.clearQueue(), this } }, { key: 'clearQueue', value () { return _queue = 0, this } }, { key: 'toggle', value () { return this.getState() ? this.hide() : this.show(), this } }, { key: 'getWidth', value () { let e; const t = document.body.style.overflow; return document.body.style.overflow = 'scroll', e = this.getCurrentWidth(), document.body.style.overflow = t, e } }, { key: 'getCurrentWidth', value () { const e = document.documentElement.clientWidth; return window.innerWidth - e } }, { key: 'setScrollableTargets', value (e) { const t = this; return Array.isArray(selectors) ? _scrollableTargets = e : e && (_scrollableTargets = [e]), eachNode(_scrollableTargets, e => t._makeScrollableTargetsElement(e)), this } }, { key: 'setFillGapMethod', value (e) { const t = e.toLowerCase(); return FILLGAP_AVAILABLE_METHODS.includes(t) ? _fillGapMethod = t : throwError('"'.concat(e, '" method is not available!')), this } }, { key: 'setFillGapSelectors', value (e) { return Array.isArray(e) ? (e.push('.'.concat(FILLGAP_CLASSNAME)), _fillGapSelectors = e) : e && (_fillGapSelectors = [e]), this } }, { key: 'setFillGapTargets', value (e) { return Array.isArray(e) ? _fillGapTargets = e : e && (_fillGapTargets = [e]), this } }, { key: '_setTemporaryScrollableTargets', value (e) { const t = this; Array.isArray(e) ? _temporaryScrollableTargets = e : e && (_temporaryScrollableTargets = [e]), eachNode(_temporaryScrollableTargets, e => t._makeScrollableTargetsElement(e)) } }, { key: '_makeScrollableTargetsElement', value (e) { _instanceof(e, Element) && e.classList.add(SCROLLABLE_CLASSNAME) } }, { key: '_fillGaps', value () { const t = this; const e = generateSelector(_fillGapSelectors); const l = document.querySelectorAll(e); eachNode(l, e => t._fillGapsElement(e)), eachNode(_fillGapTargets, e => t._fillGapsElement(e)) } }, { key: '_fillGapsElement', value (e) { const t = this.getCurrentWidth(); _instanceof(e, Element) && (_fillGapMethod === 'margin' ? e.style.marginRight = ''.concat(t, 'px') : _fillGapMethod === 'width' ? e.style.width = 'calc(100% - '.concat(t, 'px)') : e.style.paddingRight = ''.concat(t, 'px')) } }, { key: '_unfillGaps', value () { const t = this; const e = generateSelector(_fillGapSelectors); const l = document.querySelectorAll(e); eachNode(l, e => t._unfillGapsElement(e)), eachNode(_fillGapTargets, e => t._unfillGapsElement(e)) } }, { key: '_unfillGapsElement', value (e) { _instanceof(e, Element) && (e.style.marginRight = '', e.style.width = '', e.style.paddingRight = '') } }]), e }()); const scrollLock = new ScrollLock()
